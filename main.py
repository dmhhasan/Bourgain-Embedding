import argparse
from utils import *
import math 
import numpy as np
from scipy.spatial import distance
from datetime import datetime
import time 

parser = argparse.ArgumentParser("Bourgain embedding")
parser.add_argument('--graph', type = str, default='room', help = 'Choose the graph for generating the embedding')
parser.add_argument('--c', type = int, default=2, help="The 'c' value for Bourgain's algorithm")
parser.add_argument('--unweighted', type = bool, default=True, help ="Use or not edge weight for computing the embedding")
# Remote sql data
parser.add_argument('--host', type=str, default='localhost')
parser.add_argument('--username', type = str, default='')
parser.add_argument('--password', type = str, default='')
parser.add_argument('--database', type=str, default='')
args = parser.parse_args()


if __name__=="__main__":
    if args.graph == 'room':
        adj, node_mapping, index_mapping = load_graph(args)
        dist_mat = get_shortest_path_distances(args, adj)

        dist_mat[dist_mat==np.inf] = adj.shape[0]+2
        # Apply Bourgain's embedding algorithm
        c = args.c
        n = adj.shape[0]
        j_max = math.floor(np.log(n))
        i_max = c*j_max

        #Steps:
        #(1) For every j, 1 <= j <= floor(log n), generate a random subset A_j of the set of nodes. A_j is generated by picking each node in the graph independently with probability 1/2^j. For example, nodes in A_1 will be picked with prob 1/2.
        #(2) Now for every i, 1 <= i <= c*floor(log n), and every node u,
        #                              f_{ij}(u) = maximum distance_{v in A_j} between u and v
        #Some notes:
        #-Note that f_{1j}(u) = f_{2j}(u) = f_{3j}(u)...
        #-distance between u and v refers to the shortest path distance in the underlying graph


        # Generate subsets of nodes (A_j) by independenty picking each node with probability 1/2^j
        A = {}
        for j in range(1,j_max+1):
            prob = 1/(2**j)
            #np.random.seed(int(time.time()))
            u = np.random.rand(n)
            indices = np.where(u<prob)[0]
            A[j] = indices
        # Initialize the embedding matrix with zeros
        emb = np.zeros(shape=(n, i_max*j_max))

        # Update embedding for each of the node
        for node in range(n):
            list = []
            for j in range(1, j_max+1):
                max_dist = np.max(dist_mat[node,A[j]])
                for i in range(1, i_max+1):
                    list.append(max_dist)
            emb[node] = list
        Path("output/").mkdir(parents=True, exist_ok=True)
        np.savez("output/"+args.graph+"_embedding.npz", embedding = emb, node_mapping = node_mapping, index_mapping = index_mapping)
        
        print("Embedding shape:",emb.shape)
        print(emb)
        print(emb[100])
    
        #f = open("output/ratio_0_pairs.txt", "w")
        # Calculate distortion
        #index_mapping[0] = "root_0"
        ratio = [] 
        spd_list = []
        total_cnt = 0
        for i in range(n):
            for j in range(i+1, n):
                spd = dist_mat[i,j]
                ed = distance.euclidean(emb[i], emb[j])
                ratio.append(ed/spd)
                if(ed/spd ==0):
                #     f.write(str(index_mapping[i])+" "+str(index_mapping[j]) + "  "+str(ed)+"  "+str(spd)+"\n")
                    spd_list.append(spd)
                total_cnt+=1
        ratio_arr = np.array(ratio)
        print("Minimum ratio:",np.min(ratio_arr))
        print("Maximum ratio:",np.max(ratio_arr))
        print("Average ratio:",np.mean(ratio_arr))
        print("Standard deviation:",np.std(ratio_arr))
        print("0 ratio statistics: min {}, max {}, mean {}, std {}".format(np.min(spd_list), np.max(spd_list), np.mean(spd_list), np.std(spd_list)))
        print("total {}, only 0 {}".format(total_cnt, len(spd_list)))
    
    elif args.graph == 'doctor':
        emb, node_mapping, index_mapping = load_graph(args)
        Path("output/").mkdir(parents=True, exist_ok=True)
        np.savez("output/"+args.graph+"_embedding.npz", embedding = emb, node_mapping = node_mapping, index_mapping = index_mapping)
        
        
        print("Embedding shape:",emb.shape)# Embedding shape: (13500, 21)
        #print(emb[100]) 
        #print(node_mapping)

    elif args.graph == 'medication':
        emb, node_mapping, index_mapping = load_graph(args)
        Path("output/").mkdir(parents=True, exist_ok=True)
        np.savez("output/"+args.graph+"_embedding.npz", embedding = emb, node_mapping = node_mapping, index_mapping = index_mapping)
        
        
        print("Embedding shape:",emb.shape)# Embedding shape: (13500, 21)
        #print(emb[100]) 
        #print(node_mapping)




# MariaDB [uihc]> select * from physicians limit 5;
# +------+------+-----+
# | clip | sid  | pid |
# +------+------+-----+
# |      |   99 |   1 |
# | A003 |   59 |   2 |
# | A005 |   22 |   3 |
# | A007 |   44 |   4 |
# | A017 |   44 |   5 |
# +------+------+-----+
# clip: doctor id.
# sid: specialty
